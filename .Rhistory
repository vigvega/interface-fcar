fc$attributes)
})
print(labels)
}
labels(fc)
shiny::runApp()
library(fcaR)
fc
fc$concepts
fc$objects
fc$closure(fc$attributes[º])
fc$closure(fc$attributes[1])
fc$concepts
fc$concepts$intents()
fc$concepts$extents()
fc$concepts
fc$concepts[1][2]
fc$concepts[1][1]
fc$concepts[1]$sub(1)
fc$concepts[1]$print()
fc$obj_concept()
fc$obj_concept("Mercury")
fc$obj_concept("Mercury")
fc$concepts
fc$obj_concept("Mercury")
fc$att_concept("far")
fc$obj_concept(c("Mercury", "Venus"))
fc$obj_concept(c("Mercury", "Earth"))
fc$obj_concept(c("Mercury"))
runApp()
runApp()
runApp()
shiny::runApp()
fc$att_concept("far")
c <- fc$att_concept("far")
c
class(c)
which(fc$concepts == c)
fc$concepts
c
fc$concepts[3] == c
fc$is_concept(c)
which(fc$is_concept(c))
fc$concepts$to_latex()
which(fc$concepts$to_latex() == c$to_latex())
fc$concepts[3]$to_latex() == c$to_latex()
fc$concepts[3]$to_latex()
c$to_latex()
fc$concepts
c
fc$closure(S)
s <- Set$new
s <- Set$new(fc$attributes)
s$assign(far=1)
s
fc$closure(s)
fc$implications$closure(s)
c <- fc$att_concept("far")
c
fc$concepts
fc$concepts
clas(fc$concepts)
fc$concepts
class(fc$concepts)
fc$concepts[1]
fc$concepts
fc$concepts[1]
fc$implications
"Mars" %in% fc$concepts[1]
fc$concepts[1]
"Mars" %in% fc$concepts[1]$extents()
"Mars" %in% fc$concepts[1]$extents()
fc$concepts[1]$extents()
shiny::runApp()
c
fc$concepts$subconcepts(c)
fc$concepts
knitr::opts_chunk$set(echo = TRUE)
find_one_concept <- function(lattice, closed_set) {
intents <- lattice$intents()
v <- as(as(as_vector(closed_set), "matrix"), "dgCMatrix")
Matrix::which(fcaR:::.equal_sets(v, intents))
}
library(fcaR)
fc <- FormalContext$new(planets)
fc$find_concepts()
S <- Set$new(fc$attributes)
S$assign(small = 1)
closed_set <- fc$closure(S)
c <- fc$concepts[find_one_concept(lattice = fc$concepts,  closed_set = closed_set)]
# Devuelve el índice del concepto
c
fc$concepts$subconcepts(c)
shiny::runApp()
c <- fc$concepts[2]
i <- fc$concepts[2]
t <- fc$concepts[12]
fc$concepts$subconcepts(i)
fc$concepts$subconcepts(t)
fc$concepts$subconcepts(i)
t
fc$concepts$subconcepts(i)
fc$concepts$superconcepts(t)
fc$concepts$subconcepts(i)$intents()
# Init
i <- fc$concepts[2]
# Target
t <- fc$concepts[12]
sub <- fc$concepts$subconcepts(i)
sup <- fc$concepts$superconcepts(t)
subIntents <- sub$intents()
subExtents <- sub$extents()
supIntents <- sup$intents()
supExtents <- sup$extents()
Matrix::which(fcaR:::.equal_sets(subIntents, supIntents) & fcaR:::.equal_sets(subExtents, supExtents))
Matrix::which(fcaR:::.equal_sets(subIntents, supIntents) & fcaR:::.equal_sets(subExtents, supExtents))
sub
sup
Matrix::which(fcaR:::.equal_sets(subIntents, supIntents) && fcaR:::.equal_sets(subExtents, supExtents))
Matrix::which(fcaR:::.equal_sets(subIntents, supIntents))
Matrix::which(fcaR:::.equal_sets(subIntents, supIntents))
sub
sup
subIntents
supIntents
indentical <- Matrix::which(fcaR:::.equal_sets(subIntents, supIntents))
which(Matrix::colSums(indentical) > 1)
identical <- fcaR:::.equal_sets(subIntents, supIntents)
identical
which(Matrix::colSums(identical) > 1)
colSums(identical)
Matrix::colSums(identical)
which(Matrix::colSums(identical) == 1)
which(Matrix::colSums(identical) == 1)
sub
sup
# Init
i <- fc$concepts[2]
# Target
t <- fc$concepts[12]
sub <- fc$concepts$subconcepts(i)
sup <- fc$concepts$superconcepts(t)
subIntents <- sub$intents()
subExtents <- sub$extents()
supIntents <- sup$intents()
supExtents <- sup$extents()
sameAtt <- fcaR:::.equal_sets(subIntents, supIntents)
sameObj <- identical <- fcaR:::.equal_sets(subExtents, supExtents)
which(Matrix::colSums(sameAtt) == 1 & Matrix::colSums(sameObj) == 1)
runApp()
runApp()
i
t
# Concepts perteneciente al subreticulo
# i: concepto inicial
# t: concepto objetivo
# lo que hago es simplemente la intersección
getSublattice <- function(fc, i, t){
sub <- fc$concepts$subconcepts(i)
sup <- fc$concepts$superconcepts(t)
subIntents <- sub$intents()
subExtents <- sub$extents()
supIntents <- sup$intents()
supExtents <- sup$extents()
sameAtt <- fcaR:::.equal_sets(subIntents, supIntents)
sameObj <- identical <- fcaR:::.equal_sets(subExtents, supExtents)
indexes <- which(Matrix::colSums(sameAtt) == 1 & Matrix::colSums(sameObj) == 1)
sublattice <- fc$concepts$sublattice(indexes)
return(sublattice)
}
getSublattice(fc, i, t)
runApp()
g
c
lattice()
sublattice <- getSublattice(fc, i ,t)
sublattice
sublattice$size()
sublattice$lower_neighbours()
sublattice$lower_neighbours(sublattice[1])
g
g <- getGraph(fc$concepts)
g
g$edges
g$edges$to[1]
g$edges$to[2]
g$edges$to[4]
g$edges$to[6]
g$edges$from[6]
g$edges$from[1]
g$edges$from[2]
g$edges$from[3]
g$edges$to[1]
g$edges$to[2]
g$edges$to[3]
g$edges$to[5]
g$edges$to[10]
g$nodes$id[1]
igraph::neighbors(g, v = as.numeric(g$nodes$id[1]), mode = "out")
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
getSublattice(fc, fc$concepts[2], fc$concepts[6])
getSublattice(fc, fc$concepts[2], fc$concepts[12])
getSublattice(fc, fc$concepts[2], fc$concepts[10])
getSublattice(fc, fc$concepts[2], fc$concepts[12])
fc
fc$concepts
getSublattice(fc, fc$concepts[2], fc$concepts[12])
fc$concepts[2]
i
t
getSublattice(fc, i, t)
# Concepts perteneciente al subreticulo
# i: concepto inicial
# t: concepto objetivo
# lo que hago es simplemente la intersección
getSublattice <- function(concepts, i, t){
sub <- concepts$subconcepts(i)
sup <- concepts$superconcepts(t)
subIntents <- sub$intents()
subExtents <- sub$extents()
supIntents <- sup$intents()
supExtents <- sup$extents()
sameAtt <- fcaR:::.equal_sets(subIntents, supIntents)
sameObj <- identical <- fcaR:::.equal_sets(subExtents, supExtents)
indexes <- which(Matrix::colSums(sameAtt) == 1 & Matrix::colSums(sameObj) == 1)
sublattice <- concepts$sublattice(indexes)
return(sublattice)
}
getSublattice(fc, i, t)
runApp()
init <- getOneConcept(fca(), 2)
init <- getOneConcept(fc, 2)
target <- getOneConcept(fc, 12)
sublattice <- getSublattice(fc$concepts, init, target)
sublattice
getGraph(sublattice)
showPlot2(getGraph(sublattice))
knitr::opts_chunk$set(echo = TRUE)
# Init
i <- fc$concepts[2]
# Target
t <- fc$concepts[12]
sub <- fc$concepts$subconcepts(i)
sup <- fc$concepts$superconcepts(t)
subIntents <- sub$intents()
subExtents <- sub$extents()
supIntents <- sup$intents()
supExtents <- sup$extents()
sameAtt <- fcaR:::.equal_sets(subIntents, supIntents)
sameObj <- identical <- fcaR:::.equal_sets(subExtents, supExtents)
which(Matrix::colSums(sameAtt) == 1 & Matrix::colSums(sameObj) == 1)
init <- getOneConcept(fc, 2)
target <- getOneConcept(fc, 12)
sublattice <- getSublattice(fc$concepts, init, target)
sublattice
# Concepts perteneciente al subreticulo
# i: concepto inicial
# t: concepto objetivo
# lo que hago es simplemente la intersección
getSublattice <- function(concepts, i, t){
sub <- concepts$subconcepts(i)
sup <- concepts$superconcepts(t)
subIntents <- sub$intents()
subExtents <- sub$extents()
supIntents <- sup$intents()
supExtents <- sup$extents()
sameAtt <- fcaR:::.equal_sets(subIntents, supIntents)
sameObj <- identical <- fcaR:::.equal_sets(subExtents, supExtents)
indexes <- which(Matrix::colSums(sameAtt) == 1 & Matrix::colSums(sameObj) == 1)
print(indexes)
sublattice <- concepts$sublattice(indexes)
print(sublattice)
return(sublattice)
}
getSublattice(fc$concepts, fc$concepts[2], fc$concepts[12])
getSublattice(fc$concepts, fc$concepts[2], fc$concepts[12])
getSublattice(fc$concepts, fc$concepts[2], fc$concepts[3])
# Concepts perteneciente al subreticulo
# i: concepto inicial
# t: concepto objetivo
# lo que hago es simplemente la intersección
getSublattice <- function(concepts, i, t){
sub <- concepts$subconcepts(i)
sup <- concepts$superconcepts(t)
subIntents <- sub$intents()
subExtents <- sub$extents()
supIntents <- sup$intents()
supExtents <- sup$extents()
sameAtt <- fcaR:::.equal_sets(subIntents, supIntents)
sameObj <- identical <- fcaR:::.equal_sets(subExtents, supExtents)
indexes <- which(Matrix::colSums(sameAtt) == 1 & Matrix::colSums(sameObj) == 1)
sublattice <- concepts$sublattice(indexes)
return(sublattice)
}
getSublattice(fc$concepts, fc$concepts[2], fc$concepts[3])
getSublattice(fc$concepts, fc$concepts[2], fc$concepts[6])
runApp()
fc$concepts$lower_neighbours(fc$concepts[1])
indexLowerNeighbours <- function(concepts, c){
n <- concepts$lower_neighbours(c)
intents <- n$intents()
extents <- n$extents()
allIntents <- concepts$intents()
allExtents <- concepts$extents()
sameAtt <- fcaR:::.equal_sets(intents, allIntents)
sameObj <- identical <- fcaR:::.equal_sets(extents, allExtents)
indexes <- which(Matrix::colSums(sameAtt) == 1 & Matrix::colSums(sameObj) == 1)
return(indexes)
}
fc$concepts$lower_neighbours(fc$concepts[1])
indexLowerNeighbours(fc$concepts, fc$concepts[1])
runApp()
indexLowerNeighbours(fc$concepts, fc$concepts[1])
indexLowerNeighbours(fc$concepts, fc$concepts[6])
indexLowerNeighbours(fc$concepts, fc$concepts[12])
runApp()
shinyWidgets::shinyWidgetsGallery()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
Matrix::Matrix(fc$concepts)
as.matrix(fc$concepts)
fcaR:::obtain_reduced_labels(fc$concepts, fc$concepts$intents(), fc$attributes)
fc$subcontext()
fcaR:::.subset(fc$concepts$extents())
subconcepts_matrix <- fcaR:::.subset(fc$concepts$extents())
fcaR:::obtain_reduced_labels(subconcepts_matrix, fc$concepts$intents(), fc$attributes)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
sublattice
fc$attributes[sublattice]
fc$subcontext(1)
fc$subcontext(fc$concepts[1])
fc$subcontext(1)
# Actualizo el historial
new <- rv$sublattice[chosenConcept]
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
parse_latex_table <- function(latex_text) {
# Extract only lines with data (ignore caption, label, etc.)
lines <- unlist(strsplit(latex_text, "\n"))
table_lines <- lines[grepl("&", lines) & grepl("\\\\", lines)]
# Remove LaTeX syntax
table_lines <- gsub("\\\\(hline|end\\{tabular\\}|end\\{table\\})", "", table_lines)
table_lines <- trimws(gsub("\\$|\\\\times", "×", table_lines))
# Determinar el número máximo de columnas
num_columns <- max(sapply(table_lines, function(line) length(unlist(strsplit(line, "&")))))
# Split by &
table_matrix <- do.call(rbind, lapply(table_lines, function(line) {
cells <- unlist(strsplit(line, "&"))
cells <- gsub("\\\\\\\\", "", cells)  # remove \\ at the end
cells <- trimws(cells)
# Rellenar con celdas vacías si faltan columnas
length(cells) <- num_columns
cells[is.na(cells)] <- ""
return(cells)
}))
# Remove "×" from the start and end of each row
table_matrix <- apply(table_matrix, 2, function(col) {
gsub("^×|×$", "", col)
})
# First row is header
colnames(table_matrix) <- c("-", table_matrix[1, -1])
table_matrix <- table_matrix[-1, , drop = FALSE]
# Convert to data.frame
df <- as.data.frame(table_matrix, stringsAsFactors = FALSE)
rownames(df) <- NULL
return(df)
}
parse_latex_table(fc)
parse_latex_table(fc$to_latex())
dt <- parse_latex_table(fc$to_latex())
dt
View(dt)
class(dt)
dt
class(dt)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
parse_latex_concepts <- function(latex_text) {
# Dividir en líneas
lines <- unlist(strsplit(latex_text, "\n"))
# Filtrar las líneas que contienen los conceptos
concept_lines <- grep("^\\d+:.*\\\\\\\\$", lines, value = TRUE)
# Limpiar y extraer las partes entre llaves con regex
extract_concepts <- function(line) {
# Eliminar código LaTeX innecesario
line <- gsub("\\\\mathrm\\{([^}]*)\\}", "\\1", line)
line <- gsub("\\\\ensuremath\\{?\\\\varnothing\\}?", "{}", line)
line <- gsub("\\\\left|\\\\right|\\\\\\(|\\\\\\)|\\$|\\\\,", "", line)
line <- gsub("\\\\_", "_", line)
# Extraer las partes dentro de los conjuntos con regex
matches <- regmatches(line, gregexpr("\\{[^}]*\\}", line))[[1]]
# Casos: ambos conjuntos (lhs y rhs) o solo rhs (cuando lhs está vacío)
lhs <- if (length(matches) >= 1) gsub("^\\{|\\}$", "", matches[1]) else ""
rhs <- if (length(matches) >= 2) gsub("^\\{|\\}$", "", matches[2]) else ""
return(c(lhs = lhs, rhs = rhs))
}
# Aplicar extracción
concept_pairs <- t(sapply(concept_lines, extract_concepts))
# Convertir a data.frame
df <- as.data.frame(concept_pairs, stringsAsFactors = FALSE)
df$lhs <- gsub("\\\\$", "", df$lhs)
df$rhs <- gsub("\\\\$", "", df$rhs)
return(df)
}
parse_latex_concepts(fc$concepts[1])
parse_latex_concepts(fc$concepts[1]$to_latex())
v <- parse_latex_concepts(fc$concepts[1]$to_latex())
v
v <- parse_latex_concepts(fc$concepts$to_latex())
v
v <- parse_latex_concepts(fc$concepts$to_latex())
v
View(v)
v <- parse_latex_concepts(fc$concepts[1]$to_latex())
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
fc$concepts
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
library(fcaR)
f <- FormalContext$new(/home/vi/Downloads/reclamaciones.csv)
f <- FormalContext$new("home/vi/Downloads/reclamaciones.csv")
f
reclamaciones <- read.csv("~/Downloads/reclamaciones.csv", row.names=1)
View(reclamaciones)
f <- FormalContext$new(reclamaciones)
f
f <- FormalContext$new("/home/vi/Downloads/reclamaciones.csv")
f
shiny::runApp()
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
dt[3]
c
v
dt <- parse_latex_concepts(fc$concepts$to_latex())
View(dt)
View(dt[3])
View(dt$attributes)
runApp()
fc$implications$closure(near=1)
S
fc$implications$closure(S)
fc$implications$closure(S, reduce = TRUE)
runApp()
runApp()
red <- fc$implications$closure(S, reduce = TRUE)
parse_latex_implications(red)
parse_latex_implications(red$to_latex())
red
fc$implications
red
red$to_latex()
runApp()
runApp()
runApp()
shiny::runApp()
